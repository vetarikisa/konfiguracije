Ovde je naveden opis dve veoma mocne komande koje kombinovane sa pajpvanjem (|) mogu da obave ogroman posao!!!!!!!!!!!!!!znaci sa find nadjem neke fajlove a onda proberem one koji imaju odredjeni sadrzaj!!!!!!!!!!!!! 
#########################################################
FIND
#########################################################
find location comparison-criteria search-term

NAPOMENA:ako mesto trazenje nije navedeno podrazumeva se trenutni folder; fajl moze u oba tipa navodnika kao i bez navodnika!!!!!!
find >>> izlistava sve direktorijume i direktorijume
find ./test >>> lista sve fajlove u direktorijumu test (koji se nalazi u trenutnom direktorijumu);podrazumevan je rekurzivan nacin pretrage
find ./test -name "abc.txt" >>> u direktorijumu test (koji se nalazi u trenutnom direktorijumu) trazi fajl abc.txt;podrazumevan je rekurzivan nacin pretrage
find ./test -iname "*.Php" >>> ignorise case tj velicinu slova
find ./test -maxdepth 2 -name "*.php" >>> ako hocu da zadam dubinu do koje se trazi fajl; takodje postoji i mindepth  tj od kog nivoa da se pocne pretraga
find ./test -not -name "*.php" >>> ako selim da nadjem sve fajlove osim php fajlova; umesto -not je moguce koristiti i !
find ./test -name 'abc*' ! -name '*.php' >>> takodje moguce je zadati i vise kriterijuma - nadji fajl koji pocinje sa abc i nije php ekstenzije
find -name '*.php' -o -name '*.txt' >>> u sustini gornji izraz podrazumeva da se izmedju kriterijuma nalazi AND uslov a ako zelimo OR uslov potrebno je staviti -o switch (argument) - gornja komanda trazi fajlove koji se zavrsavaju sa ekstenzijama php ili txt
NAPOMENA:fajlovi se ocito mogu staviti i u jednostruke '' i u dvostruke navodnike ""
find ./test -type f -name "abc*" >>> generalno find trazi i fajlove i direktorijum ali ako zelimo da trazimo samo fajlove onda cemo staviti type -f a ako hocemo direktorijume (foldere) type -d
find ./test ./dir2 -type f -name "abc*" >>> moguce je pretrazivati i vise razlicitih direktorijuma; jednotavno se navedu direktorijumu koje zelimo da pretrazimo
find ~ -type f -name ".*" - nadji skrivene fajlove!!!!!! u sustini kapiram da ova ~ predstavlja korenski folder ili tako nesto??? Predstavlja HOME drektorijum (fodler)!!!!!!!!!!!!!!
find . -type f -perm 0664 >>> ako zelim da nadjem fajl sa odredjenim pristupum (0664 predstavlja pristup fajla) ;i ovde je moguce koristiti negaciju tj traziti fajlove koji nemaju odredjeni permission (kao negator se koristi !) The "perm" option of find command accepts the same mode string like chmod
find /etc -maxdepth 1 -perm /u=r >>> primer upotrebe sa konkretinm slovima (bez brojeva) kao sto moze i chmod
find . -user bob >>> nadji fajlove koji propadaju odredjenom korisniku
find /var/www -group developer - naravno, moguce je traziti i fajlove koj pripadaju odredjenoj grupi
NAPOMENA:ove donje dve mi deluju posebno zanimljive!!!!!!!!!!
find / -mtime 50 >>> nadji fajlove koji su menjani poslednjih 50 dana
find / -atime 50 >>> nadji fajlove kojima je pristupano poslednjih 50 dana
find / -mtime +50 –mtime -100 >>> nadji fajlove koji su menjani izmedju 50 i 100 dana!!!!!!
find /home/bob -cmin -60 >>> nadji fajl koji je promenjen u zadnjih 60 minuta!!!! varijacije su takodje a i m tj accessed i modified!!!!!!!!! ovi m i c mi deluju kao sinonimi???
find / -size 50M >>> nadji fajl konkretne velicine
find / -size +50M -size -100M >>> nadji fajl koji oma opseg velicine
NAPOMENA: I NA KRAJU MALO EKZOTIKE
find . -type f -exec ls -s {} \; | sort -n -r | head -5 >>> ova komanda lista 5 najvecih fajlova i prikazuje ih. DETALJNIJE CU RAZMOTRITI OVU KOMANDU!!!!!
find /tmp -type f -name "*.txt" -exec rm -f {} \; >>> napr ova komanda brise sve txt fajlove iz tmp foldera
find /home/bob/dir -type f -name *.log -size +10M -exec rm -f {} \; >>> brise sve fajlove koji su veci od 10MB (nalaze se u folderu /home/bob/dir)
find /tmp -type f -empt >>> trazi prazne fajlove; naravno analogno moze da trazi i prazne foldere (direktorijume)
#####################################################
GREP  -  global regular expression print
#####################################################
Usage: grep [OPTION]... PATTERN [FILE]...
Search for PATTERN in each FILE or standard input.
PATTERN is, by default, a basic regular expression (BRE).
Example: grep -i 'hello world' menu.h main.c

Regexp selection and interpretation:
  -E, --extended-regexp     PATTERN is an extended regular expression (ERE)
  -F, --fixed-strings       PATTERN is a set of newline-separated fixed strings
  -G, --basic-regexp        PATTERN is a basic regular expression (BRE)
  -P, --perl-regexp         PATTERN is a Perl regular expression
  -e, --regexp=PATTERN      use PATTERN for matching
  -f, --file=FILE           obtain PATTERN from FILE
  -i, --ignore-case         ignore case distinctions
  -w, --word-regexp         force PATTERN to match only whole words
  -x, --line-regexp         force PATTERN to match only whole lines
  -z, --null-data           a data line ends in 0 byte, not newline

Miscellaneous:
  -s, --no-messages         suppress error messages
  -v, --invert-match        select non-matching lines
  -V, --version             print version information and exit
      --help                display this help and exit
      --mmap                ignored for backwards compatibility

Output control:
  -m, --max-count=NUM       stop after NUM matches
  -b, --byte-offset         print the byte offset with output lines
  -n, --line-number         print line number with output lines
      --line-buffered       flush output on every line
  -H, --with-filename       print the filename for each match
  -h, --no-filename         suppress the prefixing filename on output
      --label=LABEL         print LABEL as filename for standard input
  -o, --only-matching       show only the part of a line matching PATTERN
  -q, --quiet, --silent     suppress all normal output
      --binary-files=TYPE   assume that binary files are TYPE;
                            TYPE is `binary', `text', or `without-match'
  -a, --text                equivalent to --binary-files=text
  -I                        equivalent to --binary-files=without-match
  -d, --directories=ACTION  how to handle directories;
                            ACTION is `read', `recurse', or `skip'
  -D, --devices=ACTION      how to handle devices, FIFOs and sockets;
                            ACTION is `read' or `skip'
  -R, -r, --recursive       equivalent to --directories=recurse
      --include=FILE_PATTERN  search only files that match FILE_PATTERN
      --exclude=FILE_PATTERN  skip files and directories matching FILE_PATTERN
      --exclude-from=FILE   skip files matching any file pattern from FILE
      --exclude-dir=PATTERN  directories that match PATTERN will be skipped.
  -L, --files-without-match  print only names of FILEs containing no match
  -l, --files-with-matches  print only names of FILEs containing matches
  -c, --count               print only a count of matching lines per FILE
  -T, --initial-tab         make tabs line up (if needed)
  -Z, --null                print 0 byte after FILE name

Context control:
  -B, --before-context=NUM  print NUM lines of leading context
  -A, --after-context=NUM   print NUM lines of trailing context
  -C, --context=NUM         print NUM lines of output context
  -NUM                      same as --context=NUM
      --color[=WHEN],
      --colour[=WHEN]       use markers to highlight the matching strings;
                            WHEN is `always', `never', or `auto'
  -U, --binary              do not strip CR characters at EOL (MSDOS)
  -u, --unix-byte-offsets   report offsets as if CRs were not there (MSDOS)

`egrep' means `grep -E'.  `fgrep' means `grep -F'.
Direct invocation as either `egrep' or `fgrep' is deprecated.
With no FILE, or when FILE is -, read standard input.  If less than two FILEs
are given, assume -h.  Exit status is 0 if any line was selected, 1 otherwise;
if any error occurs and -q was not given, the exit status is 2.

Report bugs to: bug-grep@gnu.org
GNU Grep home page: <http://www.gnu.org/software/grep/>
General help using GNU software: <http://www.gnu.org/gethelp/>
